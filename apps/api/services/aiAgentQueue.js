/**
 * AI Agent Task Queue
 * Handles background processing of AI agent tasks using Bull
 */

const Queue = require('bull');
const logger = require('../utils/logger');
const socketIO = require('../utils/socketIOServer');
const {
  updateTaskProgress,
  updateTaskStatus,
  saveTaskResults,
  addHistoryEntry,
  updateMetrics
} = require('./aiAgentService');

// Initialize Redis-backed queue
const aiAgentQueue = new Queue('ai-agent-tasks', {
  redis: {
    host: process.env.REDIS_HOST || 'localhost',
    port: process.env.REDIS_PORT || 6379,
    password: process.env.REDIS_PASSWORD || undefined,
    db: process.env.REDIS_DB || 0
  },
  defaultJobOptions: {
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 2000
    },
    removeOnComplete: 100, // Keep last 100 completed jobs
    removeOnFail: 200 // Keep last 200 failed jobs
  }
});

// ============================================
// TASK PROCESSORS
// ============================================

/**
 * Process RESUME_GENERATION task
 */
async function processResumeGeneration(job) {
  const { taskId, userId, jobDescription, baseResumeId } = job.data;

  try {
    logger.info('Processing resume generation task', { taskId, userId });

    // Notify task started
    socketIO.notifyTaskStarted(userId, taskId, 'RESUME_GENERATION');

    // Step 1: Analyze job description (25% progress)
    await updateTaskProgress(taskId, 25, 'Analyzing job description...');
    socketIO.notifyTaskProgress(userId, taskId, 25, 'Analyzing job description...');
    await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate processing

    // TODO: Call actual AI service to analyze JD
    const jdAnalysis = {
      keywords: ['JavaScript', 'React', 'Node.js', 'AWS'],
      requiredSkills: ['Frontend Development', 'Backend Development'],
      experienceLevel: 'Senior',
      industry: 'Technology'
    };

    // Step 2: Tailor resume (50% progress)
    await updateTaskProgress(taskId, 50, 'Tailoring resume content...');
    socketIO.notifyTaskProgress(userId, taskId, 50, 'Tailoring resume content...');
    await new Promise(resolve => setTimeout(resolve, 1500));

    // TODO: Call actual AI service to tailor resume
    const tailoredResume = {
      // Placeholder - will be actual tailored resume
      message: 'Resume tailored successfully'
    };

    // Step 3: Calculate ATS score (75% progress)
    await updateTaskProgress(taskId, 75, 'Calculating ATS score...');
    socketIO.notifyTaskProgress(userId, taskId, 75, 'Calculating ATS score...');
    await new Promise(resolve => setTimeout(resolve, 1000));

    // TODO: Calculate actual ATS score
    const atsScore = 92;
    const atsBreakdown = {
      keywordMatch: 95,
      formatScore: 90,
      experienceMatch: 91
    };

    // Step 4: Save results (100% progress)
    await updateTaskProgress(taskId, 100, 'Saving results...');
    socketIO.notifyTaskProgress(userId, taskId, 100, 'Saving results...');

    const results = {
      data: tailoredResume,
      atsScore,
      atsBreakdown,
      outputFiles: [] // TODO: Generate and save PDF/DOCX files
    };

    await saveTaskResults(taskId, results);
    await updateTaskStatus(taskId, 'COMPLETED');

    // Notify completion via WebSocket
    socketIO.notifyTaskCompleted(userId, taskId, results);

    // Update metrics
    await updateMetrics(userId, 'RESUME_GENERATION', { atsScore });

    logger.info('Resume generation completed', { taskId, atsScore });

    return { success: true, results };
  } catch (error) {
    logger.error('Resume generation failed', { error: error.message, taskId });
    await updateTaskStatus(taskId, 'FAILED', { errorMessage: error.message });

    // Notify failure via WebSocket
    socketIO.notifyTaskFailed(userId, taskId, error.message);

    throw error;
  }
}

/**
 * Process COVER_LETTER_GENERATION task
 */
async function processCoverLetterGeneration(job) {
  const { taskId, userId, jobDescription, jobTitle, company } = job.data;

  try {
    logger.info('Processing cover letter generation', { taskId, userId });

    await updateTaskProgress(taskId, 25, 'Researching company...');
    await new Promise(resolve => setTimeout(resolve, 1000));

    await updateTaskProgress(taskId, 50, 'Drafting cover letter...');
    await new Promise(resolve => setTimeout(resolve, 1500));

    await updateTaskProgress(taskId, 75, 'Personalizing content...');
    await new Promise(resolve => setTimeout(resolve, 1000));

    // TODO: Call actual AI service
    const coverLetter = {
      content: `Cover letter for ${jobTitle} at ${company}`,
      // Full content will be generated by AI
    };

    const results = {
      data: coverLetter,
      atsScore: 88,
      outputFiles: []
    };

    await updateTaskProgress(taskId, 100, 'Finalizing...');
    await saveTaskResults(taskId, results);
    await updateTaskStatus(taskId, 'COMPLETED');

    await updateMetrics(userId, 'COVER_LETTER_GENERATION', {});

    logger.info('Cover letter generation completed', { taskId });

    return { success: true, results };
  } catch (error) {
    logger.error('Cover letter generation failed', { error: error.message, taskId });
    await updateTaskStatus(taskId, 'FAILED', { errorMessage: error.message });
    throw error;
  }
}

/**
 * Process COMPANY_RESEARCH task
 */
async function processCompanyResearch(job) {
  const { taskId, userId, company } = job.data;

  try {
    logger.info('Processing company research', { taskId, userId, company });

    await updateTaskProgress(taskId, 25, 'Gathering company information...');
    await new Promise(resolve => setTimeout(resolve, 1000));

    await updateTaskProgress(taskId, 50, 'Analyzing recent news...');
    await new Promise(resolve => setTimeout(resolve, 1500));

    await updateTaskProgress(taskId, 75, 'Compiling culture insights...');
    await new Promise(resolve => setTimeout(resolve, 1000));

    // TODO: Call actual research APIs (Clearbit, LinkedIn, etc.)
    const research = {
      company,
      overview: 'Company overview...',
      recentNews: [],
      culture: 'Culture insights...',
      keyPeople: [],
      funding: null
    };

    const results = {
      data: research,
      outputFiles: []
    };

    await updateTaskProgress(taskId, 100, 'Completed');
    await saveTaskResults(taskId, results);
    await updateTaskStatus(taskId, 'COMPLETED');

    await updateMetrics(userId, 'COMPANY_RESEARCH', {});

    logger.info('Company research completed', { taskId });

    return { success: true, results };
  } catch (error) {
    logger.error('Company research failed', { error: error.message, taskId });
    await updateTaskStatus(taskId, 'FAILED', { errorMessage: error.message });
    throw error;
  }
}

/**
 * Process INTERVIEW_PREP task
 */
async function processInterviewPrep(job) {
  const { taskId, userId, jobDescription, company } = job.data;

  try {
    logger.info('Processing interview prep', { taskId, userId });

    await updateTaskProgress(taskId, 25, 'Analyzing job requirements...');
    await new Promise(resolve => setTimeout(resolve, 1000));

    await updateTaskProgress(taskId, 50, 'Generating interview questions...');
    await new Promise(resolve => setTimeout(resolve, 1500));

    await updateTaskProgress(taskId, 75, 'Preparing answer guides...');
    await new Promise(resolve => setTimeout(resolve, 1000));

    // TODO: Call actual AI service
    const prepMaterial = {
      commonQuestions: [],
      technicalQuestions: [],
      behavioralQuestions: [],
      companySpecificQuestions: [],
      answerGuides: {}
    };

    const results = {
      data: prepMaterial,
      outputFiles: []
    };

    await updateTaskProgress(taskId, 100, 'Completed');
    await saveTaskResults(taskId, results);
    await updateTaskStatus(taskId, 'COMPLETED');

    await updateMetrics(userId, 'INTERVIEW_PREP', {});

    logger.info('Interview prep completed', { taskId });

    return { success: true, results };
  } catch (error) {
    logger.error('Interview prep failed', { error: error.message, taskId });
    await updateTaskStatus(taskId, 'FAILED', { errorMessage: error.message });
    throw error;
  }
}

// ============================================
// QUEUE HANDLERS
// ============================================

/**
 * Main task processor
 */
aiAgentQueue.process(async (job) => {
  const { task } = job.data;

  logger.info('Processing task', { taskId: task.id, type: task.type });

  try {
    switch (task.type) {
      case 'RESUME_GENERATION':
        return await processResumeGeneration({
          data: {
            taskId: task.id,
            userId: task.userId,
            jobDescription: task.jobDescription,
            jobTitle: task.jobTitle,
            company: task.company,
            baseResumeId: task.baseResumeId,
            tone: task.tone,
            length: task.length
          }
        });

      case 'COVER_LETTER_GENERATION':
        return await processCoverLetterGeneration({
          data: {
            taskId: task.id,
            userId: task.userId,
            jobDescription: task.jobDescription,
            jobTitle: task.jobTitle,
            company: task.company,
            baseResumeId: task.baseResumeId,
            tone: task.tone
          }
        });

      case 'COMPANY_RESEARCH':
        return await processCompanyResearch({
          data: {
            taskId: task.id,
            userId: task.userId,
            company: task.company
          }
        });

      case 'INTERVIEW_PREP':
        return await processInterviewPrep({
          data: {
            taskId: task.id,
            userId: task.userId,
            jobDescription: task.jobDescription,
            company: task.company
          }
        });

      default:
        throw new Error(`Unknown task type: ${task.type}`);
    }
  } catch (error) {
    logger.error('Task processing error', {
      error: error.message,
      taskId: task.id,
      type: task.type
    });
    throw error;
  }
});

/**
 * Queue event handlers
 */
aiAgentQueue.on('completed', (job, result) => {
  logger.info('Task completed', {
    jobId: job.id,
    taskId: job.data.task.id,
    result: result ? 'success' : 'unknown'
  });
});

aiAgentQueue.on('failed', (job, err) => {
  logger.error('Task failed', {
    jobId: job.id,
    taskId: job.data.task.id,
    error: err.message,
    attempts: job.attemptsMade
  });
});

aiAgentQueue.on('stalled', (job) => {
  logger.warn('Task stalled', {
    jobId: job.id,
    taskId: job.data.task.id
  });
});

/**
 * Enqueue a task for processing
 */
async function enqueueTask(task) {
  try {
    const job = await aiAgentQueue.add(
      {
        task,
        enqueuedAt: new Date()
      },
      {
        priority: getPriority(task.type),
        jobId: task.id // Use task ID as job ID for easy tracking
      }
    );

    logger.info('Task enqueued', { taskId: task.id, jobId: job.id });
    return job;
  } catch (error) {
    logger.error('Failed to enqueue task', { error: error.message, taskId: task.id });
    throw error;
  }
}

/**
 * Get priority for task type
 */
function getPriority(taskType) {
  const priorities = {
    RESUME_GENERATION: 5,
    COVER_LETTER_GENERATION: 4,
    JOB_APPLICATION: 10, // Highest priority
    COMPANY_RESEARCH: 3,
    INTERVIEW_PREP: 2,
    BULK_PROCESSING: 1, // Lowest priority
    JOB_TRACKER_UPDATE: 6,
    COLD_EMAIL: 4
  };

  return priorities[taskType] || 5;
}

/**
 * Get queue stats
 */
async function getQueueStats() {
  try {
    const [waiting, active, completed, failed, delayed] = await Promise.all([
      aiAgentQueue.getWaitingCount(),
      aiAgentQueue.getActiveCount(),
      aiAgentQueue.getCompletedCount(),
      aiAgentQueue.getFailedCount(),
      aiAgentQueue.getDelayedCount()
    ]);

    return {
      waiting,
      active,
      completed,
      failed,
      delayed,
      total: waiting + active + completed + failed + delayed
    };
  } catch (error) {
    logger.error('Failed to get queue stats', { error: error.message });
    throw error;
  }
}

/**
 * Pause queue processing
 */
async function pauseQueue() {
  await aiAgentQueue.pause();
  logger.info('Queue paused');
}

/**
 * Resume queue processing
 */
async function resumeQueue() {
  await aiAgentQueue.resume();
  logger.info('Queue resumed');
}

/**
 * Clean up old jobs
 */
async function cleanQueue() {
  try {
    await aiAgentQueue.clean(24 * 60 * 60 * 1000); // Remove jobs older than 24 hours
    logger.info('Queue cleaned');
  } catch (error) {
    logger.error('Failed to clean queue', { error: error.message });
  }
}

module.exports = {
  aiAgentQueue,
  enqueueTask,
  getQueueStats,
  pauseQueue,
  resumeQueue,
  cleanQueue
};
