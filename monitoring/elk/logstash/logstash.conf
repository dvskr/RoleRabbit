##
## Logstash Configuration for RoleRabbit
## Processes and aggregates logs from all application components
##

input {
  # Application logs via Filebeat
  beats {
    port => 5044
    type => "filebeat"
  }

  # Direct syslog input
  syslog {
    port => 5514
    type => "syslog"
  }

  # Docker container logs
  tcp {
    port => 5000
    codec => json
    type => "docker"
  }

  # Application API logs (HTTP)
  http {
    port => 8080
    codec => json
    type => "app-api"
  }
}

filter {
  # Parse JSON logs
  if [type] == "app-api" or [type] == "docker" {
    json {
      source => "message"
    }
  }

  # Extract log level
  if [level] {
    mutate {
      uppercase => [ "level" ]
    }
  }

  # Parse timestamps
  date {
    match => [ "timestamp", "ISO8601", "yyyy-MM-dd HH:mm:ss.SSS" ]
    target => "@timestamp"
  }

  # Grok parsing for structured logs
  grok {
    match => {
      "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{LOGLEVEL:level}\] \[%{DATA:service}\] %{GREEDYDATA:log_message}"
    }
  }

  # Extract request details from API logs
  if [type] == "app-api" and [request] {
    grok {
      match => {
        "request" => "%{WORD:method} %{URIPATHPARAM:path}"
      }
    }

    # Extract route parameters
    if [path] {
      grok {
        match => {
          "path" => "/api/templates/%{UUID:template_id}"
        }
        tag_on_failure => []
      }
    }
  }

  # Parse error stack traces
  if [error] {
    mutate {
      add_field => { "has_error" => "true" }
    }

    # Extract error type
    grok {
      match => {
        "error" => "^%{DATA:error_type}:"
      }
      tag_on_failure => []
    }
  }

  # Add environment tags
  mutate {
    add_field => {
      "environment" => "${ENVIRONMENT:production}"
      "region" => "${AWS_REGION:us-east-1}"
    }
  }

  # Parse user agent
  if [user_agent] {
    useragent {
      source => "user_agent"
      target => "ua"
    }
  }

  # GeoIP lookup for client IPs
  if [client_ip] {
    geoip {
      source => "client_ip"
      target => "geoip"
    }
  }

  # Detect security events
  if [path] =~ /admin|\.\.\/|<script|sql|union|select/ {
    mutate {
      add_tag => [ "security_alert" ]
    }
  }

  # Performance monitoring
  if [response_time] {
    if [response_time] > 1000 {
      mutate {
        add_tag => [ "slow_request" ]
      }
    }
  }

  # Error categorization
  if [status] >= 500 {
    mutate {
      add_tag => [ "server_error" ]
    }
  } else if [status] >= 400 {
    mutate {
      add_tag => [ "client_error" ]
    }
  }

  # Remove sensitive data
  mutate {
    remove_field => [ "password", "token", "api_key", "credit_card" ]
  }
}

output {
  # Send to Elasticsearch
  elasticsearch {
    hosts => ["${ELASTICSEARCH_HOSTS:elasticsearch:9200}"]
    index => "rolerabbit-logs-%{+YYYY.MM.dd}"
    user => "${ELASTICSEARCH_USER:elastic}"
    password => "${ELASTICSEARCH_PASSWORD}"

    # Use document ID to prevent duplicates
    document_id => "%{[@metadata][fingerprint]}"
  }

  # Send critical errors to dedicated index
  if "server_error" in [tags] or [level] == "ERROR" or [level] == "FATAL" {
    elasticsearch {
      hosts => ["${ELASTICSEARCH_HOSTS:elasticsearch:9200}"]
      index => "rolerabbit-errors-%{+YYYY.MM.dd}"
      user => "${ELASTICSEARCH_USER:elastic}"
      password => "${ELASTICSEARCH_PASSWORD}"
    }
  }

  # Send security events to security index
  if "security_alert" in [tags] {
    elasticsearch {
      hosts => ["${ELASTICSEARCH_HOSTS:elasticsearch:9200}"]
      index => "rolerabbit-security-%{+YYYY.MM.dd}"
      user => "${ELASTICSEARCH_USER:elastic}"
      password => "${ELASTICSEARCH_PASSWORD}"
    }
  }

  # Send performance metrics to separate index
  if "slow_request" in [tags] {
    elasticsearch {
      hosts => ["${ELASTICSEARCH_HOSTS:elasticsearch:9200}"]
      index => "rolerabbit-performance-%{+YYYY.MM.dd}"
      user => "${ELASTICSEARCH_USER:elastic}"
      password => "${ELASTICSEARCH_PASSWORD}"
    }
  }

  # Debug output (development only)
  if "${ENVIRONMENT:production}" == "development" {
    stdout {
      codec => rubydebug
    }
  }
}
